  TweakDB 是什么

  TweakDB 是 Cyberpunk 2077 的数据驱动配置数据库，类似于其他游戏引擎中的 DataTable 或配置系统。它的核心作用是：

  1. 分离数据与代码：将游戏参数（数值、引用、配置）从 C++ 代码中抽离
  2. 热重载支持：可在运行时修改数据而无需重新编译代码
  3. 统一访问接口：为 C++ 和脚本提供统一的数据访问方式

  TweakDB 的三层架构

  .tweak 文件 (数据源)
      ↓
  TweakDB (C++ 核心数据库)
      ↓
  TweakDBInterface (自动生成的访问接口)
      ↓
  Scripts/C++ (消费者)

  第一层：.tweak 文件（数据定义）

  这些是人类可读的数据文件，存储在 r6\depot\base\gameplay\static_data\ 目录下。例如定义 AI 角色的数据：

  AIRole.Patrol:
  {
      someParameter = 1.0;
      anotherSetting = true;
  }

  AIRole.Follower:
  {
      threatTrackingPreset = "TargetTracking.FollowerPreset";
  }

  第二层：TweakDB 核心（C++ 实现）

  从 tweakDB.h 中可以看到核心数据结构：

  class TweakDB
  {
      // 紧凑的打包数据存储
      HashMap<TweakDBID, FlatValue> m_flats;
      HashMap<TweakDBID, UniquePtr<ISerializable>> m_records;

      // 线程安全访问
      RWSpinLock m_lock;

      // 查询接口
      Bool TryGetFlat(TweakDBID recordID, FlatValue& out) const;
      ISerializable* GetRecord(TweakDBID id) const;
  };

  第三层：TweakDBID 系统（唯一标识符）

  从 tweakDBId.h 可以看到，TweakDB 使用哈希 ID 系统：

  struct TDBIDHelper : public IScriptable
  {
      void funcCreate();      // 从字符串创建 ID
      void funcAppend();      // 追加路径
      void funcPrepend();     // 前置路径
      void funcToNumber();    // 转为数字哈希
  };

  在脚本中使用 T"" 语法创建 TweakDBID：

  // 从 aiRole.script 中的实际例子：
  public const override function GetTweakRecordId() : TweakDBID
  {
      return T"AIRole.Patrol";  // 编译时转为哈希 ID
  }

  TweakDB 在 AI::Role 系统中的应用

  让我展示 TweakDB 如何与 AI::Role 集成：

  1. Script 层声明需要的 TweakDB 记录

  从 aiRole.script 中：

  import class AIRole extends IScriptable
  {
      // 这个函数返回 TweakDB 中对应的记录 ID
      import function GetRoleTweakRecord() : AIRole_Record;

      public const virtual function GetTweakRecordId() : TweakDBID
      {
          return TDBID.None();  // 基类返回空，子类覆盖
      }
  }

  class AIPatrolRole extends AIRole
  {
      public const override function GetTweakRecordId() : TweakDBID
      {
          return T"AIRole.Patrol";  // 指向 TweakDB 中的具体记录
      }
  }

  2. C++ 层实现桥接到 TweakDB

  从之前分析的 aiRole.cpp：

  WeakHandle<game::data::AIRole_Record> Role::GetRoleTweakRecord() const
  {
      // 1. 调用脚本的 GetTweakRecordId() 获取 ID
      TweakDBID tweakId = GetTweakRecordId();

      // 2. 从 TweakDB 查询对应的记录
      return game::GetTweakDBSystem()->GetRecord<game::data::AIRole_Record>(tweakId);
  }

  3. 记录类型（Auto-Generated）

  从 tweakDBRecords.h 可以看到记录是自动生成的：

  //=============================================================================
  //                 This file has been autogenerated.
  //                  Any manual edits will be lost!
  //=============================================================================

  namespace game {
  namespace data {

  GAME_TWEAK_DB_API void AddRecord(TweakDB& tweakDB, const Uint32 hash, const RecordID path);

  // 每个 .tweak 文件中的记录类型都会生成对应的 C++ 类
  // 例如 AIRole_Record, GameplayLogicPackage_Record 等

  } // namespace data
  } // namespace game

  实际使用示例

  从 aiRole.script 中可以看到多处使用 TweakDB：

  // 示例 1: 设置目标追踪预设
  ((ScriptedPuppet)owner).GetTargetTrackerComponent().SetCurrentPreset(
      T"TargetTracking.FollowerPreset"  // TweakDB 引用
  );

  // 示例 2: 武器槽位引用
  friendlyTargetweaponChangeListener.slotID = T"AttachmentSlots.WeaponRight";

  // 示例 3: 状态效果引用
  StatusEffectHelper.RemoveStatusEffect(m_owner, T"BaseStatusEffect.FollowerDefeated");

  // 示例 4: 从角色记录获取威胁追踪预设
  characterRecord = TweakDBInterface.GetCharacterRecord(
      ((ScriptedPuppet)owner).GetRecordID()
  );
  if(characterRecord)
  {
      ((ScriptedPuppet)owner).GetTargetTrackerComponent().SetCurrentPreset(
          characterRecord.ThreatTrackingPreset().GetID()
      );
  }

  TweakDB 的优势

  1. 数据热重载：修改 .tweak 文件后可立即在游戏中生效（通过 CET 等工具）
  2. 模组友好：模组可以添加新的 TweakDB 记录而无需修改代码
  3. 类型安全：通过自动生成的 Record 类提供强类型访问
  4. 性能优化：使用哈希 ID 查询，避免字符串比较
  5. 集中管理：所有游戏数据集中在 .tweak 文件中，便于平衡和调整

  总结

  TweakDB 是连接数据和代码的桥梁：

  - 设计师在 .tweak 文件中定义数据
  - TweakDB 系统加载并索引这些数据
  - C++/脚本代码通过 T"Path.To.Record" 语法访问数据
  - AI::Role 系统通过 GetTweakRecordId() 将角色类型映射到对应的 TweakDB 配置

  这种架构使得游戏逻辑（代码）和游戏数值（数据）完全分离，是现代游戏引擎的标准做法。